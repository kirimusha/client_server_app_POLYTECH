#ifndef DIJKSTRA_H
#define DIJKSTRA_H

#include <vector>
#include <queue>
#include <limits>
#include <utility>
#include <algorithm>

using namespace std;

// Принцип работы:

// Начинаем с точки старта.
// Считаем, что путь от старта до себя = 0, а до всех остальных = бесконечность.

// Используем обычную очередь (не приоритетную), так как все рёбра имеют вес 1.
// Обрабатываем вершины в порядке их удалённости от старта.

// Для каждой вершины проверяем её соседей:
// если сосед ещё не посещён — его расстояние = текущее расстояние + 1.

// Помечаем вершину как посещённую и добавляем её соседей в очередь.

// Повторяем, пока очередь не опустеет.

// Главное, что нужно запомнить:

// Для графов с единичными весами достаточно обычного поиска в ширину.
// Каждая вершина посещается ровно один раз.
// Алгоритм работает быстрее, чем классический Дейкстра (O(V+E) вместо O((V+E)logV)).

// Константа для представления бесконечности
const int INF = numeric_limits<int>::max();

class Dijkstra {
private:
    int n;  // Количество вершин
    vector<vector<int>> graph;  // Список смежности
    
public:
    // Конструктор, пример использования: Dijkstra dijkstra(10)
    Dijkstra(int vertices) : n(vertices) {
        graph.resize(n);
    }
    
    // Добавление ребра в граф (вес всегда равен 1)
    void addEdge(int from, int to) {
        graph[from].push_back(to); 
        // graph[from] - обращаемся к списку смежности вершины from
        // .push_back(to) - добавляем вершину to в этот список
    }
    
    // Основная функция поиска кратчайших путей
    // Возвращает вектор кратчайших расстояний от start до всех вершин
    vector<int> findShortestPaths(int start) {
        // Создает вектор из n элементов, каждый равен INF
        vector<int> dist(n, INF);
        dist[start] = 0;
        
        // Обычная очередь
        queue<int> q; // Создание пустой очереди целых чисел
        q.push(start); // Добавление стартовой вершины в очередь
        // push() - это метод добавления элемента в конец контейнера
        
        while (!q.empty()) {
            int u = q.front(); // front() - просмотр первого элемента
            q.pop(); // pop() - удаление первого элемента
            
            // Проходим по всем соседям вершины u
            for (int v : graph[u]) {
                // Если вершина ещё не посещена
                if (dist[v] == INF) {
                    dist[v] = dist[u] + 1;
                    q.push(v);
                }
            }
        }
        
        return dist;
    }
    
    // Нахождение кратчайшего пути от start до end
    // Возвращает длину пути и сам путь
    pair<int, vector<int>> findPath(int start, int end) {
        // Вектор расстояний и родителей
        // Создает вектор размера n, все элементы = INF
        vector<int> dist(n, INF);
        // Создает вектор размера n, все элементы = -1
        vector<int> parent(n, -1);
        dist[start] = 0;
        
        // parent[i] = откуда пришли в i

        // Обычная очередь
        queue<int> q;
        q.push(start);
        
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            
            // Если достигли конечной вершины, можем завершить
            if (u == end) {
                break;
            }
            
            // Проходим по всем соседям u
            for (int v : graph[u]) {      
                if (dist[v] == INF) {       // Если сосед не посещен
                    dist[v] = dist[u] + 1;  // Расстояние = предыдущее + 1
                    parent[v] = u;          // Запоминаем, откуда пришли
                    q.push(v);              // Добавляем в очередь
                }
            }
        }
        
        // Восстанавливаем путь
        vector<int> path;
        
        // Если путь не существует
        if (dist[end] == INF) {
            return {INF, path};
        }
        
        // Восстанавливаем путь от end к start
        for (int v = end; v != -1; v = parent[v]) {
            // push_back() - это метод добавления элемента в конец вектора (динамического массива)
            path.push_back(v);
        }
        
        // Разворачиваем путь (чтобы был от start к end)
        reverse(path.begin(), path.end());
        
        return {dist[end], path}; // длина кратчайшего пути и сам путь в виде вектора вершин
    }
    
    // Очистка графа
    // Цикл проходит по каждому элементу graph:
    // auto& adj - ссылка на внутренний вектор (список смежности для одной вершины)
    // adj.clear() - очищает этот внутренний вектор
    void clear() {
        for (auto& adj : graph) {
            adj.clear();
        }
    }
    // До очистки:
        // graph = [
        //     [1, 2, 3],     // adj для вершины 0
        //     [0, 2],        // adj для вершины 1  
        //     [0, 1],        // adj для вершины 2
        //     [0]            // adj для вершины 3
        // ]

        // // После очистки:
        // graph = [
        //     [],  // adj для вершины 0 очищен
        //     [],  // adj для вершины 1 очищен
        //     [],  // adj для вершины 2 очищен
        //     []   // adj для вершины 3 очищен
        // ]
};

#endif // DIJKSTRA_H
