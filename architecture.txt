├── CMakeLists.txt             # Файл для сборки проекта
├── graph.txt                  # Файл с описанием графа
├── source/                    # Исходный код
└───── server/                 # Серверная часть
   │   ├── Server.h            # Заголовочный файл класса сервера
   │   ├── Server.cpp          # Реализация сервера
   │   └── ServerMain.cpp      # Точка входа сервера (main функция)
   │
   ├── client/                 # Клиентская часть
   │   ├── Client.h            # Заголовочный файл класса клиента
   │   ├── Client.cpp          # Реализация клиента
   │   └── ClientMain.cpp      # Точка входа клиента (main функция)
   │
   ├── common/                 # Общие компоненты для клиента и сервера
   │   ├── Graph.h             # Заголовочный файл класса графа
   │   ├── Graph.cpp           # Реализация методов графа
   │   ├── Protocol.h          # Общие константы, структуры для сетевого протокола
   │   ├── Protocol.cpp        # Реализация функций сериализации и десериализации
   │   ├── UDPProtocol.h       # Протокол UDP с механизмом безопасной доставки (есть ACK)
   │   └── Dijkstra.h          # Алгоритм Дейкстры
   │
   └── utils/                  # Вспомогательные утилиты
       ├── FileReader.h        # Чтение графа из файла
       ├── FileReader.cpp      # Реализация чтения графа из файла
       ├── InputParser.h       # Парсинг входных данных
       ├── InputParser.cpp     # Реализация парсера
       ├── Validator.h         # Валидация данных
       ├── Validator.cpp       # Реализация валидации
       ├── Logger.h            # Логирование
       └── Logger.cpp          # Реализация логгера
       
       
       
Как запустить:

1. Сначала запустите сервер (в одном терминале):

2. Затем запустите клиент (в другом терминале):

Примеры:
./client 127.0.0.1 tcp 8080      # Подключение к локальному TCP серверу
./client localhost udp 12345     # Подключение к локальному UDP серверу


Терминал 1 (сервер):

cd ~/client_server_app/build
./server 8080 tcp

Терминал 2 (клиент):
Ctrl+Shift+T
cd ~/client_server_app/build
./client 127.0.0.1 tcp 8080

Если хотите протестировать UDP:

Терминал 1 (сервер):

./server 12345 udp

Терминал 2 (клиент):

./client 127.0.0.1 udp 12345

После запуска клиента:

1. Введите описание графа в формате: A B, B C, C D, D E, E F, F G, A C, B D
2. Затем введите начальную и конечную вершины: A G
3. Программа найдет путь между вершинами!

Завершить работу сервера:

Ctrl + C



как именно я обрабатываю нескольких клиентов + какие системные вызовы и какие механизмы
kill all server




Для TCP протокола механизм многопоточность

Главный поток принимает подключения через accept()
Для каждого нового клиента создается отдельный поток
Каждый поток работает независимо, обрабатывая своего клиента
Потоки хранятся в векторе clientThreads для управления жизненным циклом

Для UDP протокола механизм однопоточная обработка в цикле

Один поток обрабатывает все запросы
Каждая датаграмма обрабатывается последовательно
Состояние клиента не сохраняется между запросами

socket() - создание сокета, первый параметр - домен - определяет семейство адресов, которые будет использовать сокет, второй это тип udp или tcp, потом 0 это протокол по умолчанию выбирается для предыдущего параметра
bind() - связывает сокет с конкретным портом и IP-адресом
listen() - переводит сокет в режим прослушивания, у меня создаёт очередь из 5ти клиентов
accept() - принятие подключения (только TCP) извлекает первое ожидающее подключение из очереди (созданной listen()) создаёт новый сокет специально для общения с этим клиентом и возвращает дескриптор нового сокета. Без очереди вы бы теряли клиентов в моменты, когда главный поток занят вызовом accept() или созданием потоков.
recv() / recvfrom() - получение данных, возвращает количество байт или 0 если клиент закрыл соединение и нечего читать
send() / sendto() - отправка данных
close() - закрытие сокета. Освобождение файлового дескриптора, завершение сетевого соединения (для TCP), освобождение ресурсов ядра

Главный поток:
1. socket() bind() listen() accept() (ждет)
2. Новый клиент accept() возвращает clientSocket
3. create thread(handleTCPClient, clientSocket)
4. Возврат к accept() (ждет следующего клиента)

Поток клиента:
1. receiveTCP() - получает запрос
2. processRequest() - обрабатывает
3. sendTCP() - отправляет ответ
4. close(clientSocket) - закрывает соединение



 cd ~/client_server_app_POLYTECH-master/build                                                6m 24s
./client 127.0.0.1 tcp 8080


cd ~/client_server_app_POLYTECH-master                                                      6m 24s
rm -rf build
mkdir build
cd build
cmake ..
make

Для udp:

КЛИЕНТ                           СЕРВЕР
------                           ------
[ДАННЫЕ: граф + вершины]
    ------------>
                                (получает данные)
                                [ACK: подтверждение]
                                <------------
(получает ACK - успех!)



КЛИЕНТ                           СЕРВЕР
------                           ------
[ДАННЫЕ]
    ------------>                (получает, отправляет ACK)
                                [ACK]  (потерян в сети)
                                X------

(ждёт 3 секунды...)
(ACK не пришёл)

[ДАННЫЕ] (повтор)
    ------------>
                                (получает, отправляет ACK)
                                [ACK]
                                <------------
(успех!)


chmod +x build/server build/client
chmod +x run_tests.exp
./run_tests.exp



Неудачные тесты:

1. Тест 2: TCP: Обработка нескольких клиентов

FAILED - Не все клиенты получили ответы

Оба клиента отправляли графы с 3 вершинами, которые не соответствуют требованию минимального количества вершин 6. Сервер правильно отверг эти запросы, но тест ожидал корректные ответы.

2. Тест 4: UDP: Работа при недоступности сервера

FAILED - Клиент не обнаружил недоступность сервера

Клиент не сообщил о потере связи или таймауте при попытке подключения к несуществующему серверу на порту 9999.

3. Тест 5: UDP: Механизм повторной отправки

FAILED - Не получено подтверждение

Клиент отправлял граф с 3 вершинами (ниже минимума), и не получил ожидаемого подтверждения пакета.

4. Тест 11: ОДЗ: 20 вершин (максимум)

FAILED - Не получен результат

В тестовом файле `test_graph_20v.txt` указаны вершины A-T, но запрашивался путь от A к J. Из вывода видно ошибка: "Конечная вершина не найдена в графе: J"

5. Тест 12: ОДЗ: 21 вершина (выше максимума)

FAILED - Сервер принял граф выше максимума

Сервер обработал граф с 21 вершиной и вернул результат, хотя должен был отклонить его, так как максимально допустимое количество вершин - 20.

6. Тест 13: Алгоритм: Несуществующий путь

FAILED - Таймаут

Клиент отправил граф с двумя несвязными компонентами (A-B-C и X-Y-Z) и запросил путь между A и X. Вместо ожидаемого сообщения о несуществующем пути сервер вернул "[ERROR] Неверный запрос", после чего тест завершился по таймауту.




проблемы:

1. Валидация на стороне сервера: 
   - Сервер не проверяет максимальное количество вершин (21 вершина принята)
   - Ошибки валидации могут обрабатываться непоследовательно

2. Обработка несвязных графов: 
   - При запросе пути между вершинами из разных компонент сервер возвращает "Неверный запрос" вместо "Путь не существует"

3. Тестовые данные: 
   - Тест с 20 вершинами содержит ошибку (отсутствует вершина J в запросе)
   - Некоторые тесты используют графы с меньшим количеством вершин, чем требуется

4. UDP механизмы: 
   - Недостаточная обработка случаев недоступности сервера
   - Проблемы с подтверждением пакетов

5. Ожидания в тестах: 
   - Некоторые тесты ожидают конкретных сообщений, которые не соответствуют фактическому поведению программы
